from pyhrf.ndarray import xndarray
from pyhrf.boldsynth.hrf import getCanoHRF
import re
from scipy.ndimage import label, sum as ndi_sum
from scipy.ndimage.morphology import generate_binary_structure
import os
import glob
import matplotlib.pyplot as plt
from matplotlib import gridspec
from nilearn.image import load_img, resample_img, image
import nibabel as nib
import numpy as np
from nilearn.plotting import plot_stat_map, plot_roi, plot_anat, plot_epi
from path_names import *

# Loading file
PARCELLATION_MASK = nib.load(os.path.join(INPUT_FOLDER,'mask_parcel.nii'))

TR = 2.76
# Time length of the HRF (in seconds, default: 25.0)
#HRF_DURATION = TR * 10.0
HRF_DURATION = 25

# Time resolution of the HRF
DT = TR / 4.0


## Functions

def find_ppms_maps(output_dir):
    """Find the PPM maps generated by PyHRF.
        
    Parameters
    ----------
    output_dir : str
        Path of the PyHRF output directory.

    Returns
    -------
    dict 
        Dictionary whose keys are the contrasts labels and the ppm files are the values.
        
    Examples
    --------
    >>> print(find_ppms_maps('/home/jariasal/scipy_notebook/output/114/pyhrf_output'))
    {'Foot': 'jde_vem_ppm_a_nrl_Foot.nii', 'Lips': 'jde_vem_ppm_a_nrl_Lips.nii', 'Finger': 'jde_vem_ppm_a_nrl_Finger.nii'}
    
    """
    ppm_maps = (os.path.basename(p) for p in glob.glob(os.path.join(output_dir, 'jde_vem_ppm_a_nrl*.nii')))
    pattern_name = re.compile("jde_vem_ppm_a_nrl_(.*)\.nii")

    ppm_dic = {pattern_name.match(ppm).group(1).replace('_', ' ').title(): ppm
               for ppm in ppm_maps}

    return ppm_dic


def find_activated_parcels(ppm_map, parcels_mask, ppm_threshold, cluster_size_threshold):
    """Find activated parcels for a given PPM map.

    Parameters
    ----------
    ppm_map : ~numpy.ndarray
        Posterior Probability Map data
    parcels_mask : ~numpy.ndarray
        parcellation mask data
    ppm_threshold : float
        threshold for the PPM
    cluster_size_threshold : int
        threshold for the size of the cluster of activated neurons

    Returns
    -------
    list of int
        Activated parcels
        
    Examples
    --------
    >>> from nilearn.image import load_img
    >>> parcels_img = load_img(PARCELLATION_MASK)
    >>> parcels_img_data = parcels_img.get_data()
    >>> ppm_img = load_img(os.path.join('/home/jariasal/scipy_notebook/output/114/pyhrf_output', 'jde_vem_ppm_a_nrl_Finger.nii'))
    >>> print(find_activated_parcels(ppm_img.get_data(), parcels_img_data, 0.99999, 50))
    [ 21 101 290 417 485]

    """
    ppm_map[np.isnan(ppm_map)] = 0.
    ppm_map_mask = (ppm_map >= ppm_threshold)  # binary ppm_map
    binary_structure = generate_binary_structure(3, 2)  # structuring element that defines neighborhood connections

    ppm_map_labeled, nb_labels = label(ppm_map_mask, structure=binary_structure)

    if not nb_labels:  # always select at least one cluster
        ppm_threshold = ppm_map.max() * 0.9999
        ppm_map_mask = (ppm_map >= ppm_threshold)
        ppm_map_labeled, nb_labels = label(ppm_map_mask, structure=binary_structure)
        print("ppm_threshold set to {}".format(ppm_threshold))

    # number of active voxels for each cluster
    clusters_size = ndi_sum(ppm_map_mask, ppm_map_labeled, index=np.arange(nb_labels+1))

    # clusters (labels) whose number of active voxels is greater than the threshold
    active_clusters = clusters_size >= cluster_size_threshold

    if not active_clusters.any():  # threshold for cluster size is too high
        cluster_size_threshold = np.amax(clusters_size)
        active_clusters = clusters_size >= cluster_size_threshold
        print("cluster_size_threshold set to {}".format(cluster_size_threshold))

    # voxels belonging the clusters whose number of active voxels is greater than the threshold
    active_clusters_mask = active_clusters[ppm_map_labeled]
    active_parcels = np.unique(parcels_mask[active_clusters_mask])

    return active_parcels

## Visualization Parameters

# PPM threshold
PPM_THRESHOLD = 0.88

# Z-maps threshold
Z_THRESHOLD = 3

# Cluster size threshold
CLUSTER_SIZE_THRESHOLD = 50  # 50 voxels correspond to a volume of 400 mm3 when the voxel size is 2 mm-isotropic.

# Posterior Probability Maps (PPM)
ppms_maps = find_ppms_maps(PYHRF_OUTPUT)

# PPM to be shown
ppm_name = 'Exp'
print(ppms_maps)
ppm_nii = ppms_maps[ppm_name]

# Cuts in z-direction axial 
cut_coords = range(55, 66, 5)

## Generate figures

# Figure configuration
plt.rc('xtick', labelsize=15)
plt.rc('ytick', labelsize=15)

fig = plt.figure(figsize=(20, 9))
gs = gridspec.GridSpec(2, 2);

# Parcellation image
parcels_img = load_img(PARCELLATION_MASK)
parcels_img_data = np.array(parcels_img.get_data())

# Anatomical image
ANAT_IMAGE = glob.glob(os.path.join(INPUT_FOLDER,'bold.nii')).pop()
anat_img = load_img(ANAT_IMAGE)

# Estimated HRF
hrf_s = xndarray.load(os.path.join(PYHRF_OUTPUT, 'jde_vem_hrf.nii'))
time_axis, canonical_hrf = getCanoHRF(duration=HRF_DURATION, dt=DT)

# Plot Canonical HRF
ax_hrf = plt.subplot(gs[1, 0])
ax_hrf.plot(time_axis, canonical_hrf, ":", label="Canonical")
ax_hrf.set_xlim([0,np.max(time_axis)])
ax_hrf.set_ylabel("amplitude", size=15)
ax_hrf.set_xlabel("time (s)", size=15)

# Plot PPM
ax_ppm = plt.subplot(gs[0, 1])
ppm_img = load_img(os.path.join(PYHRF_OUTPUT, ppm_nii))
plot_stat_map(stat_map_img=ppm_img, threshold=PPM_THRESHOLD, draw_cross=False,
              cut_coords=cut_coords, display_mode='z', 
              title='PyHRF_'+ppm_name, figure=fig, axes=ax_ppm, cmap=plt.cm.autumn)

# Plotting estimated HRF per Parcel
active_parcels = find_activated_parcels(ppm_img.get_data(), parcels_img_data,
                                        PPM_THRESHOLD, CLUSTER_SIZE_THRESHOLD)

hrf_mean = np.zeros(hrf_s.data.shape[1])
parcels_data = np.zeros_like(parcels_img_data)
for color_nb, parcel_id in enumerate(active_parcels):
    sub_cuboid = hrf_s.sub_cuboid(ROI=parcel_id).data
    hrf_mean += sub_cuboid
    parcels_data[parcels_img_data == parcel_id] = color_nb + 1

    ax_hrf.plot(time_axis, sub_cuboid, "--", color=plt.cm.gist_ncar(float(color_nb) / len(active_parcels)))   


hrf_mean /= len(active_parcels)
ax_hrf.plot(time_axis, hrf_mean, label=ppm_name, color="k", linewidth=2)

# Plotting parcels
hrf_parcels_img = nib.Nifti1Image(parcels_data, parcels_img.affine, parcels_img.get_header())
ax_rois = plt.subplot(gs[0, 0])
plot_roi(roi_img=hrf_parcels_img,
         cut_coords=cut_coords, display_mode='z', draw_cross=False, 
         title="HRF parcels", figure=fig, axes=ax_rois)

# Legend
ax_hrf.legend(fontsize=20);

# save figure
plt.savefig(os.path.join(FIGURES_OUTPUT, '%s.png' % ppm_name));
